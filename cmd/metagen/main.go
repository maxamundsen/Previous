package main

import (
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"

	"github.com/caarlos0/env/v11"
	"github.com/joho/godotenv"
)

var envtype int // set by user with cli flag

const (
	ENVIRONMENT_DEV        = iota
	ENVIRONMENT_STAGING    = iota
	ENVIRONMENT_PRODUCTION = iota
)

const METAGEN_AUTO_COMMENT = "// @Metagen -- THIS FILE WAS AUTOGENERATED BY METAGEN - DO NOT EDIT BY HAND"

// External config set by environment variables
type metagenConfiguration struct {
	MigrationConnectionString string `env:"MIGRATION_CONNECTION_STRING"`
	DbConnectionString        string `env:"DB_CONNECTION_STRING"`
	DbSchema                  string `env:"DB_SCHEMA"`
}

var config metagenConfiguration

// metagen - code generator application
//
// Generates code for other applications, such as the server application
func main() {
	envfileErr := godotenv.Load()
	if envfileErr != nil {
		fmt.Println("Error reading .env file. If it doesn't exist, copy the contents of `example.env` into `.env` in the project root directory.")
		os.Exit(1)
	}

	envErr := env.Parse(&config)
	if envErr != nil {
		fmt.Printf("%s", envErr.Error())
	}

	env := flag.String("env", "dev", "The environment to run in: dev, staging, or production")

	// Parse command-line flags
	flag.Parse()

	switch *env {
	case "dev":
		envtype = ENVIRONMENT_DEV
	case "staging":
		envtype = ENVIRONMENT_STAGING
	case "production":
		envtype = ENVIRONMENT_PRODUCTION
	default:
		fmt.Printf("Invalid environment specified: %s\n", *env)
		fmt.Println("Allowed values are: dev, staging, or production")
		os.Exit(1)
	}

	newpath := filepath.Join(".", ".metagen")
	err := os.MkdirAll(newpath, os.ModePerm)

	if err != nil {
		fmt.Println("Cannot create metagen output dir. Exiting.")
		os.Exit(1)
	}

	args := flag.Args()

	for _, arg := range args {
		switch arg {
		case "build-all":
			preBuild()
			build()
			goto End
		case "build":
			preBuild()
			goto End
		case "migrate":
			migrations(args)
			goto End
		default:
			helpmsg()
			goto End
		}
	}

End:

	if len(args) == 0 {
		helpmsg()
	}
}

func helpmsg() {
	fmt.Println("Usage: metagen [options...]")
	fmt.Println("build :: Build dependencies, generate code, then build final executables.")
	fmt.Println("migrate [up, down, goto {V}, create {migration name}] :: Deploy and create SQL migrations.")
	os.Exit(1)
}

func preBuild() {
	if envtype == ENVIRONMENT_DEV {
		fmt.Println("[DEBUG ENVIRONMENT]")
	} else if envtype == ENVIRONMENT_STAGING || envtype == ENVIRONMENT_PRODUCTION {
		fmt.Println("[RELEASE ENVIRONMENT]")
	}

	// db creation
	maybeCreateSqliteDb()

	// codegen - ORDER MATTERS HERE!
	// Generating page info supports full compile time execution.
	// This code you are running at compile time may depend on models generated by jet,
	// or CSS output from Tailwind.
	generateDebugConfig()
	generateTailwindCSS()
	generateJetModels()
	generatePageData()
}

func build() {
	compileServer()
}

func generateTailwindCSS() {
	tailwindcmd := ""

	fmt.Printf("Generating TailwindCSS stylesheet(s)")

	if runtime.GOOS == "windows" && runtime.GOARCH == "amd64" {
		tailwindcmd = "tailwindcss-windows-x64.exe"
	} else if runtime.GOOS == "darwin" && runtime.GOARCH == "arm64" {
		tailwindcmd = "tailwindcss-macos-arm64"
	} else {
		printStatus(false)
		fmt.Println("OS or ARCH not supported.")
		os.Exit(1)
	}

	// if not found, try to install it
	if _, err := os.Stat(tailwindcmd); err != nil {
		if runtime.GOOS == "windows" && runtime.GOARCH == "amd64" {
			handleCmdOutput(exec.Command(
				"curl.exe", "-LJO", "--output", tailwindcmd,
				"https://github.com/tailwindlabs/tailwindcss/releases/download/v4.0.1/tailwindcss-windows-x64.exe",
			).CombinedOutput())
		} else if runtime.GOOS == "darwin" && runtime.GOARCH == "arm64" {
			handleCmdOutput(exec.Command(
				"curl", "-LJO", "--output", tailwindcmd,
				"https://github.com/tailwindlabs/tailwindcss/releases/download/v4.0.1/tailwindcss-macos-arm64",
			).CombinedOutput())
			handleCmdOutput(exec.Command("chmod", "+x", tailwindcmd).CombinedOutput())
		}
	}

	cmd := exec.Command("./"+tailwindcmd, "-i", "styles/global.css", "-o", "wwwroot/css/tw.min.css", "--minify")
	handleCmdOutput(cmd.CombinedOutput())
	printStatus(true)
}

func compileServer() {
	var out []byte
	var err error

	fmt.Printf("Compiling Server Binary")

	if envtype == ENVIRONMENT_DEV {
		// include extra flags for the GC
		out, err = exec.Command("go", "build", "-gcflags=all=-N -l", "./cmd/server").CombinedOutput()
	} else {
		out, err = exec.Command("go", "build", "./cmd/server").CombinedOutput()
	}

	handleCmdOutput(out, err)
	printStatus(true)
}
