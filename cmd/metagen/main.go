package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"net/url"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	. "previous/basic"
	"reflect"
	"regexp"
	"runtime"
	"runtime/debug"
	"strings"
)

var envtype int // set by user with cli flag

const (
	ENVIRONMENT_DEV        = iota
	ENVIRONMENT_STAGING    = iota
	ENVIRONMENT_PRODUCTION = iota
)

const METAGEN_AUTO_COMMENT = "// @Metagen -- THIS FILE WAS AUTOGENERATED BY METAGEN - DO NOT EDIT BY HAND"

// metagen - code generator application
//
// Generates code for other applications, such as the server application
func main() {

	loadMetaConfig()

	env := flag.String("env", "dev", "The environment to run in: dev, staging, or production")

	// Parse command-line flags
	flag.Parse()

	switch *env {
	case "dev":
		envtype = ENVIRONMENT_DEV
	case "staging":
		envtype = ENVIRONMENT_STAGING
	case "production":
		envtype = ENVIRONMENT_PRODUCTION
	default:
		fmt.Printf("Invalid environment specified: %s\n", *env)
		fmt.Println("Allowed values are: dev, staging, or production")
		os.Exit(1)
	}

	newpath := filepath.Join(".", ".metagen")
	err := os.MkdirAll(newpath, os.ModePerm)

	if err != nil {
		fmt.Println("Cannot create metagen output dir. Exiting.")
		os.Exit(1)
	}

	args := flag.Args()

	for _, arg := range args {
		switch arg {
		case "build-all":
			preBuild()
			build()
			goto End
		case "build":
			preBuild()
			goto End
		case "migrate":
			if len(args) >= 2 {
				if args[1] == "up" {
					fmt.Println("migrating up")
				} else if args[1] == "down" {
					fmt.Println("migrating down")
				} else if args[1] == "create" {
					fmt.Println("creating migration")
				} else if args[1] == "version" {
					if len(args) >= 3 {
						fmt.Println("Migrating to version " + args[2])
					} else {
						fmt.Println("Please enter version to migrate to.")
					}
				}
			} else {
				fmt.Println("Usage: metagen migrate [up, down, create]")
			}
			goto End
		default:
			helpmsg()
			goto End
		}
	}

End:

	if len(args) == 0 {
		helpmsg()
	}
}

func helpmsg() {
	fmt.Println("Usage: metagen [options...]")
	fmt.Println("build                          Build dependencies, generate code, then build final executables.")
	fmt.Println("migrate [up, down, create]     Deploy and create SQL migrations.")
	os.Exit(1)
}

func preBuild() {
	if envtype == ENVIRONMENT_DEV {
		fmt.Println("[DEBUG ENVIRONMENT]")
	} else if envtype == ENVIRONMENT_STAGING || envtype == ENVIRONMENT_PRODUCTION {
		fmt.Println("[RELEASE ENVIRONMENT]")
	}

	// codegen
	generateDebugConfig()
	generatePageData()
	generateJetModels()
	generateTailwindCSS()
}

func build() {
	compileServer()
}

func generateTailwindCSS() {
	tailwindcmd := ""

	fmt.Printf("Generating TailwindCSS stylesheet(s)")

	if runtime.GOOS == "windows" && runtime.GOARCH == "amd64" {
		tailwindcmd = "tailwindcss-windows-x64.exe"
	} else if runtime.GOOS == "darwin" && runtime.GOARCH == "arm64" {
		tailwindcmd = "tailwindcss-macos-arm64"
	} else {
		printStatus(false)
		fmt.Println("OS or ARCH not supported.")
		os.Exit(1)
	}

	// if not found, try to install it
	if _, err := os.Stat(tailwindcmd); err != nil {
		if runtime.GOOS == "windows" && runtime.GOARCH == "amd64" {
			handleCmdOutput(exec.Command("curl.exe", "-LJO", "--output", tailwindcmd, "https://github.com/tailwindlabs/tailwindcss/releases/download/v4.0.1/tailwindcss-windows-x64.exe").CombinedOutput())
		} else if runtime.GOOS == "darwin" && runtime.GOARCH == "arm64" {
			handleCmdOutput(exec.Command("curl", "-LJO", "--output", tailwindcmd, "https://github.com/tailwindlabs/tailwindcss/releases/download/v4.0.1/tailwindcss-macos-arm64").CombinedOutput())
			handleCmdOutput(exec.Command("chmod", "+x", tailwindcmd).CombinedOutput())
		}
	}

	cmd := exec.Command("./" + tailwindcmd, "-i", "styles/global.css", "-o", "wwwroot/css/style.css", "--minify")
	handleCmdOutput(cmd.CombinedOutput())
	printStatus(true)
}


func compileServer() {
	var out []byte
	var err error

	fmt.Printf("Compiling Server Binary")

	if envtype == ENVIRONMENT_DEV {
		// include extra flags for the GC
		out, err = exec.Command("go", "build", "-gcflags=all=-N -l", "./cmd/server").CombinedOutput()
	} else {
		out, err = exec.Command("go", "build", "./cmd/server").CombinedOutput()
	}

	handleCmdOutput(out, err)
	printStatus(true)
}

// set debug constant inside the "config" package
func generateDebugConfig() {
	fmt.Printf("Generating DEBUG/RELEASE config")

	code := METAGEN_AUTO_COMMENT + "\npackage config\n\nconst (\n"

	if envtype == ENVIRONMENT_DEV {
		code += "	DEBUG = true"
	} else {
		code += "	DEBUG = false"
	}

	code += "\n)\n"

	// open file and write code to it
	in := []byte(code)

	err := os.WriteFile("./config/debug.metagen.go", in, 0644)
	handleErr(err)

	printStatus(true)
}

// Generates routes from files named `*_page.go` found recursively inside the `/src/pages` directory.
// When parsing files, we search for the first function suffixed with `Page`, if one is not found, return an error and fail compilation.
func generatePageData() {
	type RouteInfo struct {
		FileDef  string
		URL      string
		PageName string
		Package  string
		Import   string

		Identity      bool `note`
		Protected     bool `note`
		CookieSession bool `note`

		// http verbs
		HttpPost   bool `note`
		HttpGet    bool `note`
		HttpPut    bool `note`
		HttpPatch  bool `note`
		HttpDelete bool `note`
	}

	const root = "pages" // Use the /pages directory for autogenerating routes

	bi, _ := debug.ReadBuildInfo()
	parts := strings.Split(bi.Path, "/")
	module_name := parts[0]

	fmt.Printf("Generating HTTP routes")

	var routeList []RouteInfo

	// Walk the filesystem recursively
	err := filepath.Walk(root, func(pathStr string, info os.FileInfo, err error) error {
		handleErr(err)

		// Only process .go files
		if strings.HasSuffix(info.Name(), "_page.go") {
			file, err := os.Open(pathStr)
			handleErr(err)

			defer file.Close()

			fs := token.NewFileSet()
			node, err := parser.ParseFile(fs, pathStr, file, parser.ParseComments)
			handleErr(err)

			found := false

			for _, decl := range node.Decls {
				if found {
					break
				}

				// Look for function declarations
				if funcDecl, ok := decl.(*ast.FuncDecl); ok {
					ri := RouteInfo{}

					if funcDecl, ok := decl.(*ast.FuncDecl); ok {
						identifier := funcDecl.Name.Name
						// page functions MUST end with the word "Page" (case sensitive)
						if strings.HasSuffix(identifier, "Page") {
							found = true
						} else {
							continue
						}
					}

					handleErr(parseNotesFromDocComment(decl, file, &ri))

					relativePath := strings.TrimPrefix(pathStr, root)
					relativePath = strings.TrimSuffix(relativePath, "_page.go")

					dirPath := filepath.Dir(relativePath)
					lastDir := filepath.Base(dirPath)

					// Combine last directory and function name
					// Also replace underscore characters "_" with hyphen characters "-"
					ri.URL = strings.ReplaceAll(relativePath, "_", "-")
					ri.Package = lastDir
					ri.PageName = funcDecl.Name.Name

					ri.FileDef = file.Name()

					// strip names from route and use the base package name if file is index
					if strings.HasSuffix(pathStr, "/index_page.go") {
						ri.URL = path.Dir(ri.URL)
					}

					// if the route is in the "root" folder, make sure it imports the correct package.
					if ri.Package == "/" {
						ri.Package = "pages"
						ri.Import = module_name + "/" + ri.Package
						ri.PageName = strings.ReplaceAll(ri.PageName, "/", "pages")
					} else {
						ri.Import = module_name + "/" + root + "/" + removeLastPart(strings.TrimPrefix(relativePath, "/"))
					}

					routeList = append(routeList, ri)
				}
			}

			if !found {
				return fmt.Errorf("\n`%s`: Attempted to generate route, but no function suffixed with `Page` found.", file.Name())
			}
		}

		return nil
	})

	handleErr(err)

	// generate code
	routeCode := METAGEN_AUTO_COMMENT + "\npackage main\n"

	routeCode += "\nimport (\n\t\"net/http\"\n"

	for _, v := range routeList {
		if v.Identity || v.CookieSession {
			routeCode += "	. \"" + module_name + "/middleware\"\n"
			break
		}
	}

	// the go import system is horrible, so the following is a package auto-importer/ de-duplicator for code generation.
	// search through all routes, figure out their package based on the import, and possibly rename it if there already exists an import in
	// the same namespace.

	packageMap := make(map[string][]RouteInfo)
	seenImport := make(map[string]bool)

	// group by package
	for _, route := range routeList {
		// entry de-duplication
		if !seenImport[route.Import] {
			packageMap[route.Package] = append(packageMap[route.Package], route)
		}

		seenImport[route.Import] = true
	}

	// iterate over each sub-group
	for _, routes := range packageMap {
		// don't give the first instance a named import, only subsequent entries
		if len(routes) > 0 {
			routes[0].Import = fmt.Sprintf("\"%s\"", routes[0].Import)
		}

		if len(routes) > 1 {
			// modify the package name in the routeList to include the index of the sublist
			// (this is the whole point -- automatically giving duplicate packages named imports)
			for i := 1; i < len(routes); i += 1 {
				for j, v := range routeList {
					if v.Import == routes[i].Import {
						routeList[j].Package = fmt.Sprintf("%s%d", routes[i].Package, i)
					}
				}

				routes[i].Import = fmt.Sprintf("%s%d \"%s\"", routes[i].Package, i, routes[i].Import)
			}
		}
	}

	var result []RouteInfo
	for _, routes := range packageMap {
		result = append(result, routes...)
	}

	for i, _ := range result {
		routeCode += fmt.Sprintf("\t%s\n", result[i].Import)
	}

	routeCode += ")\n"
	routeCode += "\nfunc mapAutoRoutes(mux *http.ServeMux) {\n"

	for _, routeInfo := range routeList {
		printablePage := routeInfo.Package + "." + routeInfo.PageName

		if routeInfo.CookieSession {
			printablePage = fmt.Sprintf("LoadSessionFromCookie(%s)", printablePage)
		}

		if routeInfo.Identity {
			printablePage = fmt.Sprintf("LoadIdentity(%s, %t)", printablePage, routeInfo.Protected)
		}

		httpVerb := ""
		if routeInfo.HttpGet {
			httpVerb = "GET "
		} else if routeInfo.HttpPost {
			httpVerb = "POST "
		} else if routeInfo.HttpPut {
			httpVerb = "PUT "
		} else if routeInfo.HttpPatch {
			httpVerb = "PATCH "
		} else if routeInfo.HttpDelete {
			httpVerb = "DELETE "
		}

		routeCode += fmt.Sprintf("\tmux.HandleFunc(\"%s%s\", %s)\n", httpVerb, routeInfo.URL, printablePage)
	}

	routeCode += "}"

	in := []byte(routeCode)

	fileErr := os.WriteFile("./cmd/server/generated_routes.metagen.go", in, 0644)
	handleErr(fileErr)

	// generate recursive structs representing pages
	// this is used in order to reference a page without needing to actually write out the link as a string literal
	// it also lets you jump to page code whenever that page is referenced in view links or something like that.
	// essentially making dead page links a compile time error if you use this structure.

	newpath := filepath.Join(".", ".metagen/pageinfo")
	dirErr := os.MkdirAll(newpath, os.ModePerm)
	handleErr(dirErr)

	structCode := METAGEN_AUTO_COMMENT
	structCode += "\npackage pageinfo\n\n"
	// structCode += "import (\n"
	// structCode += "\t \"net/http\"\n"

	// for i, _ := range result {
	// 	structCode += fmt.Sprintf("\t%s\n", result[i].Import)
	// }

	// structCode += ")\n\n"

	structCode += "type Middleware struct {\n"
	structCode += "\tIdentity      bool\n"
	structCode += "\tProtected     bool\n"
	structCode += "\tCookieSession bool\n"
	structCode += "}\n\n"

	structCode += "type PageInfo struct {\n"
	structCode += "\tUrl            string\n"
	structCode += "\tFileDef        string\n"
	structCode += "\tMiddleware Middleware\n"
	structCode += "}\n\n"

	structCode += "var (\n"
	structCode += "\tPageInfoList []PageInfo\n"
	structCode += "\tPageInfoMap map[string]PageInfo //maps URLs to PageInfo\n\n"

	for i, route := range routeList {
		upperPath := strings.ToUpper(route.URL)
		identName := strings.ReplaceAll(upperPath, "/", "_")
		identName = strings.ReplaceAll(identName, "-", "")

		if identName == "_" {
			identName = "_INDEX"
		}

		identName = strings.TrimPrefix(identName, "_")

		structCode += fmt.Sprintf(`	%s PageInfo = PageInfo{
		Url:     "%s",
		FileDef: "/%s",
		Middleware: Middleware{
			Identity:      %t,
			Protected:     %t,
			CookieSession: %t,
		},
	}
`,
			identName,
			route.URL,
			route.FileDef,
			route.Identity,
			route.Protected,
			route.CookieSession,
		)

		if i != len(routeList)-1 {
			structCode += "\n"
		}
	}

	structCode += ")\n\n"

	structCode += "func init() {\n"
	structCode += "\tPageInfoMap = make(map[string]PageInfo)\n\n"

	for _, route := range routeList {
		upperPath := strings.ToUpper(route.URL)
		identName := strings.ReplaceAll(upperPath, "/", "_")
		identName = strings.ReplaceAll(identName, "-", "")

		if identName == "_" {
			identName = "_INDEX"
		}

		identName = strings.TrimPrefix(identName, "_")

		structCode += fmt.Sprintf("\tPageInfoMap[\"%s\"] = %s\n", route.URL, identName)

	}

	structCode += "\n\tPageInfoList = []PageInfo{\n"

	for _, route := range routeList {
		upperPath := strings.ToUpper(route.URL)
		identName := strings.ReplaceAll(upperPath, "/", "_")
		identName = strings.ReplaceAll(identName, "-", "")

		if identName == "_" {
			identName = "_INDEX"
		}

		identName = strings.TrimPrefix(identName, "_")

		structCode += fmt.Sprintf("\t\t%s,\n", identName)
	}

	structCode += "\t}\n"
	structCode += "}\n"

	structCode_b := []byte(structCode)

	structFileErr := os.WriteFile("./.metagen/pageinfo/pageinfo.metagen.go", structCode_b, 0644)
	handleErr(structFileErr)

	printStatus(true)
}

func compileJet() {
	fmt.Printf("Compiling Jet generator")

	os.Setenv("CGO_ENABLED", "1")

	cmd := exec.Command("go", "build", "./cmd/jet")
	cmd.Dir = "./tools/jet-2.12.0"
	handleCmdOutput(cmd.CombinedOutput())

}

func generateJetModels() {
	bin := ""
	jetdir := ".jet"

	if runtime.GOOS == "windows" {
		bin = "./tools/jet-2.12.0/jet.exe"
	} else {
		bin = "./tools/jet-2.12.0/jet"
	}

	os.RemoveAll(jetdir)

	// compile bin if not exists
	if _, err := os.Stat(bin); err != nil {
		compileJet()
	}

	var connectionString string
	var databaseSchema string

	switch envtype {
	case ENVIRONMENT_DEV:
		connectionString = config.DevDbConnectionString
		databaseSchema = config.DevDbSchema
	case ENVIRONMENT_STAGING:
		connectionString = config.StagingDbConnectionString
		databaseSchema = config.StagingDbSchema
	case ENVIRONMENT_PRODUCTION:
		connectionString = config.ProdDbConnectionString
		databaseSchema = config.ProdDbSchema
	}

	fmt.Printf("Generating SQL models (jet)")

	filename, _ := parseSQLiteFilename(connectionString)

	if _, err := os.Stat(filename); err != nil {
		printStatus(false)
		fmt.Println("\n" + err.Error())
		os.Exit(1)
	}

	databaseType := "sqlite"

	cmd := exec.Command(bin, "-source="+databaseType, "-dsn="+connectionString, "-schema="+databaseSchema, "-path="+jetdir)

	handleCmdOutput(cmd.CombinedOutput())
	printStatus(true)
}

func parseSQLiteFilename(dsn string) (string, error) {
	u, err := url.Parse(dsn)
	if err != nil {
		return "", err
	}

	// For simple file paths
	if u.Scheme == "" {
		return u.Path, nil
	}

	// For more complex DSNs
	if u.Scheme == "file" {
		return u.Opaque, nil
	}

	return "", fmt.Errorf("invalid DSN format: %s", dsn)
}

func compileMigrator() {
	fmt.Printf("Compiling Migration Tool")

	handleCmdOutput(exec.Command("cd", "./tools/migrate-4.18.1", "&&", "go", "build", "./cmd/migrate").CombinedOutput())

}

// given an ast.Decl, and destination struct, look at the struct for any
// boolean fields with the struct tag `Note`. If valid notes are found in the given Decl doc string
// set the tagged booleans to true on the input struct.
func parseNotesFromDocComment(decl ast.Decl, file *os.File, dest any) error {
	re := regexp.MustCompile(`@(\w+)`)

	var identifier string
	var docstring string

	var docNotes []string
	var validNotes []string

	// check if decl is a function
	if funcDecl, ok := decl.(*ast.FuncDecl); ok {
		identifier = funcDecl.Name.Name
		docstring = funcDecl.Doc.Text()
	}

	matches := re.FindAllStringSubmatch(docstring, -1)

	for _, match := range matches {
		// match[1] contains the first capture group (the word after '@')
		docNotes = append(docNotes, match[1])
	}

	v := reflect.ValueOf(dest).Elem()
	t := v.Type()

	if v.Kind() != reflect.Struct {
		return fmt.Errorf("\ndestination struct must be a pointer to a struct")
	}

	for i := 0; i < v.NumField(); i++ {
		field := t.Field(i)

		// Look for the `Note` tag in the struct field
		if field.Tag == "note" {
			if Contains(docNotes, field.Name) {
				v.Field(i).SetBool(true)
			}

			validNotes = append(validNotes, field.Name)
		}
	}

	for _, v := range docNotes {
		if !Contains(validNotes, v) {
			return fmt.Errorf("\n`%s`: Unknown note `@%s`, Identifier: `%s`\n\tValid values are: %v", file.Name(), v, identifier, validNotes)
		}
	}

	return nil
}

// helpers

// given /foo/bar/baz -> baz
func removeLastPart(s string) string {
	lastSlashIndex := strings.LastIndex(s, "/")

	if lastSlashIndex == -1 {
		return s
	}

	return s[:lastSlashIndex]
}

func printStatus(b bool) {
	var status string

	if b {
		status = "SUCCESS"
	} else {
		status = "FAILED"
	}

	fmt.Printf("... %s\n", status)
}

func handleCmdOutput(out []byte, err error) {
	if err != nil {
		fmt.Printf("%s\n", out)
		fmt.Printf("%s\n", err.Error())
		os.Exit(1)
	}
}

func handleErr(err error) {
	if err != nil {
		printStatus(false)
		fmt.Println(err.Error())
		os.Exit(1)
	}
}