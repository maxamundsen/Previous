package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"net/url"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	. "previous/basic"
	"reflect"
	"regexp"
	"runtime"
	"runtime/debug"
	"strings"
)

var OS string

var envtype int

const (
	ENVIRONMENT_DEV        = iota
	ENVIRONMENT_STAGING    = iota
	ENVIRONMENT_PRODUCTION = iota
)

const METAGEN_AUTO_COMMENT = "// @Metagen -- THIS FILE WAS AUTOGENERATED BY METAGEN - DO NOT EDIT BY HAND"

// metagen - code generator application
//
// Generates code for other applications, such as the server application
func main() {
	// check operating system before running build command
	OS = runtime.GOOS

	loadMetaConfig()

	env := flag.String("env", "dev", "The environment to run in: dev, staging, or production")

	// Parse command-line flags
	flag.Parse()

	switch *env {
	case "dev":
		envtype = ENVIRONMENT_DEV
	case "staging":
		envtype = ENVIRONMENT_STAGING
	case "production":
		envtype = ENVIRONMENT_PRODUCTION
	default:
		fmt.Printf("Invalid environment specified: %s\n", *env)
		fmt.Println("Allowed values are: dev, staging, or production")
		os.Exit(1)
	}

	args := flag.Args()

	for _, arg := range args {
		switch arg {
		case "build":
			build()
			goto End
		case "migrate":
			if len(args) >= 2 {
				if args[1] == "up" {
					fmt.Println("migrating up")
				} else if args[1] == "down" {
					fmt.Println("migrating down")
				} else if args[1] == "create" {
					fmt.Println("creating migration")
				} else if args[1] == "version" {
					if len(args) >= 3 {
						fmt.Println("Migrating to version " + args[2])
					} else {
						fmt.Println("Please enter version to migrate to.")
					}
				}
			} else {
				fmt.Println("Usage: metagen migrate [up, down, create]")
			}
			goto End
		default:
			helpmsg()
			goto End
		}
	}

End:

	if len(args) == 0 {
		helpmsg()
	}

	fmt.Printf("\n")
}

func helpmsg() {
	fmt.Println("Usage: metagen [options...]")
	fmt.Println("build                          Build dependencies, generate code, then build final executables.")
	fmt.Println("migrate [up, down, create]     Deploy and create SQL migrations.")
	os.Exit(1)
}

func build() {
	if envtype == ENVIRONMENT_DEV {
		fmt.Println("[DEBUG ENVIRONMENT]")
	} else if envtype == ENVIRONMENT_STAGING || envtype == ENVIRONMENT_PRODUCTION {
		fmt.Println("[RELEASE ENVIRONMENT]")
	}

	// codegen
	generateDebugConfig()
	generateHTTPRoutes()
	generateJetModels()
	generateTailwindCSS()

	// compileServer()
}

func generateTailwindCSS() {
	tailwindcmd := ""

	fmt.Printf("Generating TailwindCSS stylesheet(s)")

	if OS == "windows" {
		log.Fatal("OS unsupported. Compilation failed.")
	} else if OS == "darwin" {
		tailwindcmd = "tailwindcss-macos-arm64"
	}

	out, err := exec.Command("./"+tailwindcmd, "-i", "styles/global.css", "-o", "wwwroot/css/style.css", "--minify").CombinedOutput()
	if err != nil {
		printStatus(false)
		fmt.Printf("%s", out)
		os.Exit(1)
	} else {
		printStatus(true)
	}

	fmt.Printf("\n")
}

// func compileServer() {
// 	var out []byte
// 	var err error

// 	fmt.Printf("Compiling Server Binary")

// 	if envtype == ENVIRONMENT_DEV {
// 		// include extra flags for the GC
// 		out, err = exec.Command("go", "build", "-gcflags=all=-N -l", "./cmd/server").CombinedOutput()
// 	} else {
// 		out, err = exec.Command("go", "build", "./cmd/server").CombinedOutput()
// 	}

// 	handleCmdOutput(out, err)

// 	fmt.Printf("\n")
// }

// set debug constant inside the "config" package
func generateDebugConfig() {
	fmt.Printf("Generating DEBUG/RELEASE config")

	code := METAGEN_AUTO_COMMENT + "\npackage config\n\nconst (\n"

	if envtype == ENVIRONMENT_DEV {
		code += "	DEBUG = true"
	} else {
		code += "	DEBUG = false"
	}

	code += "\n)\n"

	// open file and write code to it
	in := []byte(code)

	err := os.WriteFile("./config/debug.metagen.go", in, 0644)
	handleErr(err)

	printStatus(true)
	fmt.Printf("\n")
}

// Generates routes from files named `*_controller.go` found recursively inside the `/src/pages` directory.
// When parsing files, we search for the first function suffixed with `Controller`, if one is not found, return an error and fail compilation.
func generateHTTPRoutes() {
	type RouteInfo struct {
		URL        string
		Controller string
		Package    string
		Import     string

		Identity      bool `note`
		Protected     bool `note`
		CookieSession bool `note`

		// http verbs
		HttpPost   bool `note`
		HttpGet    bool `note`
		HttpPut    bool `note`
		HttpPatch  bool `note`
		HttpDelete bool `note`
	}

	const root = "pages" // Use the /pages directory for autogenerating routes

	bi, _ := debug.ReadBuildInfo()
	parts := strings.Split(bi.Path, "/")
	module_name := parts[0]

	fmt.Printf("Generating HTTP routes")

	var routeList []RouteInfo

	// Walk the filesystem recursively
	err := filepath.Walk(root, func(pathStr string, info os.FileInfo, err error) error {
		handleErr(err)

		// Only process .go files
		if strings.HasSuffix(info.Name(), "_controller.go") {
			file, err := os.Open(pathStr)
			handleErr(err)

			defer file.Close()

			fs := token.NewFileSet()
			node, err := parser.ParseFile(fs, pathStr, file, parser.ParseComments)
			handleErr(err)

			found := false

			for _, decl := range node.Decls {
				if found {
					break
				}

				// Look for function declarations
				if funcDecl, ok := decl.(*ast.FuncDecl); ok {
					ri := RouteInfo{}

					if funcDecl, ok := decl.(*ast.FuncDecl); ok {
						identifier := funcDecl.Name.Name
						// controller functions MUST end with the word "Controller" (case sensitive)
						if strings.HasSuffix(identifier, "Controller") {
							found = true
						} else {
							continue
						}
					}

					handleErr(parseNotesFromDocComment(decl, file, &ri))

					relativePath := strings.TrimPrefix(pathStr, root)
					relativePath = strings.TrimSuffix(relativePath, "_controller.go")

					dirPath := filepath.Dir(relativePath)
					lastDir := filepath.Base(dirPath)

					// Combine last directory and function name
					// Also replace underscore characters "_" with hyphen characters "-"
					ri.URL = strings.ReplaceAll(relativePath, "_", "-")
					ri.Package = lastDir
					ri.Controller = funcDecl.Name.Name

					// strip names from route and use the base package name if file is index
					if strings.HasSuffix(pathStr, "/index_controller.go") {
						ri.URL = path.Dir(ri.URL)
					}

					// if the route is in the "root" folder, make sure it imports the correct package.
					if ri.Package == "/" {
						ri.Package = "pages"
						ri.Import = module_name + "/" + ri.Package
						ri.Controller = strings.ReplaceAll(ri.Controller, "/", "pages")
					} else {
						ri.Import = module_name + "/" + root + "/" + removeLastPart(strings.TrimPrefix(relativePath, "/"))
					}

					routeList = append(routeList, ri)
				}
			}

			if !found {
				return fmt.Errorf("\n`%s`: Attempted to generate route, but no `Controller` found.", file.Name())
			}
		}

		return nil
	})

	handleErr(err)

	// generate code
	code := METAGEN_AUTO_COMMENT + "\npackage main\n"

	code += "\nimport (\n\t\"net/http\"\n"

	for _, v := range routeList {
		if v.Identity || v.CookieSession {
			code += "	. \"previous/middleware\"\n"
			break
		}
	}

	// the go import system is horrible, so the following is a package auto-importer/ de-duplicator for code generation.
	// search through all routes, figure out their package based on the import, and possibly rename it if there already exists an import in
	// the same namespace.

	packageMap := make(map[string][]RouteInfo)
	seenImport := make(map[string]bool)

	// group by package
	for _, route := range routeList {
		// entry de-duplication
		if !seenImport[route.Import] {
			packageMap[route.Package] = append(packageMap[route.Package], route)
		}

		seenImport[route.Import] = true
	}

	// iterate over each sub-group
	for _, routes := range packageMap {
		// don't give the first instance a named import, only subsequent entries
		if len(routes) > 0 {
			routes[0].Import = fmt.Sprintf("\"%s\"", routes[0].Import)
		}

		if len(routes) > 1 {
			// modify the package name in the routeList to include the index of the sublist
			// (this is the whole point -- automatically giving duplicate packages named imports)
			for i := 1; i < len(routes); i += 1 {
				for j, v := range routeList {
					if v.Import == routes[i].Import {
						routeList[j].Package = fmt.Sprintf("%s%d", routes[i].Package, i)
					}
				}

				routes[i].Import = fmt.Sprintf("%s%d \"%s\"", routes[i].Package, i, routes[i].Import)
			}
		}
	}

	var result []RouteInfo
	for _, routes := range packageMap {
		result = append(result, routes...)
	}

	for i, _ := range result {
		code += fmt.Sprintf("\t%s\n", result[i].Import)
	}

	code += ")\n"
	code += "\nfunc mapAutoRoutes(mux *http.ServeMux) {\n"

	for _, routeInfo := range routeList {
		printableController := routeInfo.Package + "." + routeInfo.Controller

		if routeInfo.CookieSession {
			printableController = fmt.Sprintf("LoadSessionFromCookie(%s)", printableController)
		}

		if routeInfo.Identity {
			printableController = fmt.Sprintf("LoadIdentity(%s, %t)", printableController, routeInfo.Protected)
		}

		httpVerb := ""
		if routeInfo.HttpGet {
			httpVerb = "GET "
		} else if routeInfo.HttpPost {
			httpVerb = "POST "
		} else if routeInfo.HttpPut {
			httpVerb = "PUT "
		} else if routeInfo.HttpPatch {
			httpVerb = "PATCH "
		} else if routeInfo.HttpDelete {
			httpVerb = "DELETE "
		}

		code += fmt.Sprintf("\tmux.HandleFunc(\"%s%s\", %s)\n", httpVerb, routeInfo.URL, printableController)
	}

	code += "}"

	in := []byte(code)

	fileErr := os.WriteFile("./cmd/server/generated_routes.metagen.go", in, 0644)
	handleErr(fileErr)

	printStatus(true)
	fmt.Printf("\n")
}

func compileJet() {
	fmt.Printf("Compiling Jet generator")

	cmd := exec.Command("go", "build", "./cmd/jet")
	cmd.Dir = "./tools/jet-2.12.0"
	handleCmdOutput(cmd.CombinedOutput())

	fmt.Printf("\n")
}

func generateJetModels() {
	bin := "./tools/jet-2.12.0/jet"
	jetdir := ".jet"

	os.RemoveAll(jetdir)

	// compile bin if not exists
	if _, err := os.Stat(bin); err != nil {
		compileJet()
	}

	var connectionString string
	var databaseType string
	var databaseSchema string

	switch envtype {
	case ENVIRONMENT_DEV:
		connectionString = config.DevDbConnectionString
		databaseType = config.DevDbType
		databaseSchema = config.DevDbSchema
	case ENVIRONMENT_STAGING:
		connectionString = config.StagingDbConnectionString
		databaseType = config.StagingDbType
		databaseSchema = config.StagingDbSchema
	case ENVIRONMENT_PRODUCTION:
		connectionString = config.ProdDbConnectionString
		databaseType = config.ProdDbType
		databaseSchema = config.ProdDbSchema
	}

	fmt.Printf("Generating SQL models (jet)")

	if databaseType == "sqlite" || databaseType == "sqlite3" {
		filename, _ := parseSQLiteFilename(connectionString)

		if _, err := os.Stat(filename); err != nil {
			printStatus(false)
			fmt.Println("\n" + err.Error())
			os.Exit(1)
		}
	}
	cmd := exec.Command(bin, "-source="+databaseType, "-dsn="+connectionString, "-schema="+databaseSchema, "-path="+jetdir)

	handleCmdOutput(cmd.CombinedOutput())

	fmt.Printf("\n")
}

func parseSQLiteFilename(dsn string) (string, error) {
	u, err := url.Parse(dsn)
	if err != nil {
		return "", err
	}

	// For simple file paths
	if u.Scheme == "" {
		return u.Path, nil
	}

	// For more complex DSNs
	if u.Scheme == "file" {
		return u.Opaque, nil
	}

	return "", fmt.Errorf("invalid DSN format: %s", dsn)
}

func compileMigrator() {
	fmt.Printf("Compiling Migration Tool")

	handleCmdOutput(exec.Command("cd", "./tools/migrate-4.18.1", "&&", "go", "build", "./cmd/migrate").CombinedOutput())

	fmt.Printf("\n")
}

// given an ast.Decl, and destination struct, look at the struct for any
// boolean fields with the struct tag `Note`. If valid notes are found in the given Decl doc string
// set the tagged booleans to true on the input struct.
func parseNotesFromDocComment(decl ast.Decl, file *os.File, dest any) error {
	re := regexp.MustCompile(`@(\w+)`)

	var identifier string
	var docstring string

	var docNotes []string
	var validNotes []string

	// check if decl is a function
	if funcDecl, ok := decl.(*ast.FuncDecl); ok {
		identifier = funcDecl.Name.Name
		docstring = funcDecl.Doc.Text()
	}

	matches := re.FindAllStringSubmatch(docstring, -1)

	for _, match := range matches {
		// match[1] contains the first capture group (the word after '@')
		docNotes = append(docNotes, match[1])
	}

	v := reflect.ValueOf(dest).Elem()
	t := v.Type()

	if v.Kind() != reflect.Struct {
		return fmt.Errorf("\ndestination struct must be a pointer to a struct")
	}

	for i := 0; i < v.NumField(); i++ {
		field := t.Field(i)

		// Look for the `Note` tag in the struct field
		if field.Tag == "note" {
			if Contains[string](docNotes, field.Name) {
				v.Field(i).SetBool(true)
			}

			validNotes = append(validNotes, field.Name)
		}
	}

	for _, v := range docNotes {
		if !Contains[string](validNotes, v) {
			return fmt.Errorf("\n`%s`: Unknown note `@%s`, Identifier: `%s`\n\tValid values are: %v", file.Name(), v, identifier, validNotes)
		}
	}

	return nil
}

// helpers

// given /foo/bar/baz -> baz
func removeLastPart(s string) string {
	lastSlashIndex := strings.LastIndex(s, "/")

	if lastSlashIndex == -1 {
		return s
	}

	return s[:lastSlashIndex]
}

func printStatus(b bool) {
	var status string

	if b {
		status = "SUCCESS"
	} else {
		status = "FAILED"
	}

	fmt.Printf("... %s", status)
}

func handleCmdOutput(out []byte, err error) {
	if err != nil {
		printStatus(false)
		fmt.Printf("\n")
		fmt.Printf("%s", out)
		os.Exit(1)
	} else {
		printStatus(true)
	}
}

func handleErr(err error) {
	if err != nil {
		printStatus(false)
		fmt.Println(err.Error())
		os.Exit(1)
	}
}
