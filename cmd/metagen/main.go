// Warning - code contained in this file is kinda ugly. If the scope of this tool expands maybe we'll factor some things out,
// but for now we're just going to leave everything in one place.
package main

import (
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"net/url"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	. "previous/basic"
	"reflect"
	"regexp"
	"runtime"
	"runtime/debug"
	"strconv"
	"strings"
	"time"

	"github.com/golang-migrate/migrate/v4"
	_ "github.com/golang-migrate/migrate/v4/database/sqlite3"
	_ "github.com/golang-migrate/migrate/v4/source/file"

	"github.com/caarlos0/env/v11"
	"github.com/joho/godotenv"
)

var envtype int // set by user with cli flag

const (
	ENVIRONMENT_DEV        = iota
	ENVIRONMENT_STAGING    = iota
	ENVIRONMENT_PRODUCTION = iota
)

const METAGEN_AUTO_COMMENT = "// @Metagen -- THIS FILE WAS AUTOGENERATED BY METAGEN - DO NOT EDIT BY HAND"

// External config set by environment variables
type metagenConfiguration struct {
	MigrationConnectionString string `env:"MIGRATION_CONNECTION_STRING"`
	DbConnectionString        string `env:"DB_CONNECTION_STRING"`
	DbSchema                  string `env:"DB_SCHEMA"`
}

var config metagenConfiguration

// metagen - code generator application
//
// Generates code for other applications, such as the server application
func main() {
	envfileErr := godotenv.Load()
	if envfileErr != nil {
		fmt.Println("Error reading .env file. If it doesn't exist, copy the contents of `example.env` into `.env` in the project root directory.")
		os.Exit(1)
	}

	envErr := env.Parse(&config)
	if envErr != nil {
		fmt.Printf("%s", envErr.Error())
	}

	env := flag.String("env", "dev", "The environment to run in: dev, staging, or production")

	// Parse command-line flags
	flag.Parse()

	switch *env {
	case "dev":
		envtype = ENVIRONMENT_DEV
	case "staging":
		envtype = ENVIRONMENT_STAGING
	case "production":
		envtype = ENVIRONMENT_PRODUCTION
	default:
		fmt.Printf("Invalid environment specified: %s\n", *env)
		fmt.Println("Allowed values are: dev, staging, or production")
		os.Exit(1)
	}

	newpath := filepath.Join(".", ".metagen")
	err := os.MkdirAll(newpath, os.ModePerm)

	if err != nil {
		fmt.Println("Cannot create metagen output dir. Exiting.")
		os.Exit(1)
	}

	args := flag.Args()

	for _, arg := range args {
		switch arg {
		case "build-all":
			preBuild()
			build()
			goto End
		case "build":
			preBuild()
			goto End
		case "migrate":
			migrations(args)
			goto End
		default:
			helpmsg()
			goto End
		}
	}

End:

	if len(args) == 0 {
		helpmsg()
	}
}

// create
func maybeCreateSqliteDb() {
	if _, err := os.Stat("./example.db"); err != nil {
		fmt.Printf("Creating new sqlite database")
		err := os.WriteFile("./example.db", nil, 0755)
		if err != nil {
			fmt.Printf("Error creating Sqlite database.")
			os.Exit(1)
		}

		m, err := migrate.New(
			"file://./migrations",
			config.MigrationConnectionString,
		)

		if err != nil {
			printStatus(false)
			fmt.Println(err.Error())
			os.Exit(1)
		}

		mErr := m.Up()
		if mErr != nil {
			printStatus(false)
			fmt.Println(err.Error())
			os.Exit(1)
		}

		printStatus(true)
	}
}

// handle the running and creation of migrations
func migrations(args []string) {
	if len(args) < 2 {
		fmt.Println("Usage: metagen migrate [up, down, goto {V}, create {migration name}]")
		os.Exit(1)
	}

	maybeCreateSqliteDb()

	m, err := migrate.New(
		"file://./migrations",
		config.MigrationConnectionString,
	)

	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}

	migrateNum := 0

	if len(args) >= 3 && args[1] != "create" {
		var parseErr error
		migrateNum, parseErr = strconv.Atoi(args[2])
		if parseErr != nil {
			fmt.Println("Please provide a valid migration number.")
			os.Exit(1)
		}
	}

	m.PrefetchMigrations = migrate.DefaultPrefetchMigrations

	switch args[1] {
	case "up":
		err := m.Up()
		if err != nil {
			fmt.Println(err.Error())
		}
	case "down":
		err := m.Down()
		if err != nil {
			fmt.Println(err.Error())
		}
	case "goto":
		err := m.Migrate(uint(migrateNum))
		if err != nil {
			fmt.Println(err.Error())
		}
	case "create":
		if len(args) < 3 {
			fmt.Println("Please provide a name for the new migration.")
			os.Exit(1)
		}
		createCmd("./migrations", time.Now(), defaultTimeFormat, args[2], "sql", true, 7, true)
	}
}

const (
	defaultTimeFormat = "20060102150405"
	defaultTimezone   = "UTC"
)

var (
	errInvalidSequenceWidth     = errors.New("Digits must be positive")
	errIncompatibleSeqAndFormat = errors.New("The seq and format options are mutually exclusive")
	errInvalidTimeFormat        = errors.New("Time format may not be empty")
)

func createFile(filename string) error {
	// create exclusive (fails if file already exists)
	// os.Create() specifies 0666 as the FileMode, so we're doing the same
	f, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0666)

	if err != nil {
		return err
	}

	return f.Close()
}

func nextSeqVersion(matches []string, seqDigits int) (string, error) {
	if seqDigits <= 0 {
		return "", errInvalidSequenceWidth
	}

	nextSeq := uint64(1)

	if len(matches) > 0 {
		filename := matches[len(matches)-1]
		matchSeqStr := filepath.Base(filename)
		idx := strings.Index(matchSeqStr, "_")

		if idx < 1 { // Using 1 instead of 0 since there should be at least 1 digit
			return "", fmt.Errorf("Malformed migration filename: %s", filename)
		}

		var err error
		matchSeqStr = matchSeqStr[0:idx]
		nextSeq, err = strconv.ParseUint(matchSeqStr, 10, 64)

		if err != nil {
			return "", err
		}

		nextSeq++
	}

	version := fmt.Sprintf("%0[2]*[1]d", nextSeq, seqDigits)

	if len(version) > seqDigits {
		return "", fmt.Errorf("Next sequence number %s too large. At most %d digits are allowed", version, seqDigits)
	}

	return version, nil
}

func timeVersion(startTime time.Time, format string) (version string, err error) {
	switch format {
	case "":
		err = errInvalidTimeFormat
	case "unix":
		version = strconv.FormatInt(startTime.Unix(), 10)
	case "unixNano":
		version = strconv.FormatInt(startTime.UnixNano(), 10)
	default:
		version = startTime.Format(format)
	}

	return
}

func createCmd(dir string, startTime time.Time, format string, name string, ext string, seq bool, seqDigits int, print bool) error {
	if seq && format != defaultTimeFormat {
		return errIncompatibleSeqAndFormat
	}

	var version string
	var err error

	dir = filepath.Clean(dir)
	ext = "." + strings.TrimPrefix(ext, ".")

	if seq {
		matches, err := filepath.Glob(filepath.Join(dir, "*"+ext))

		if err != nil {
			return err
		}

		version, err = nextSeqVersion(matches, seqDigits)

		if err != nil {
			return err
		}
	} else {
		version, err = timeVersion(startTime, format)

		if err != nil {
			return err
		}
	}

	versionGlob := filepath.Join(dir, version+"_*"+ext)
	matches, err := filepath.Glob(versionGlob)

	if err != nil {
		return err
	}

	if len(matches) > 0 {
		return fmt.Errorf("duplicate migration version: %s", version)
	}

	if err = os.MkdirAll(dir, os.ModePerm); err != nil {
		return err
	}

	for _, direction := range []string{"up", "down"} {
		basename := fmt.Sprintf("%s_%s.%s%s", version, name, direction, ext)
		filename := filepath.Join(dir, basename)

		if err = createFile(filename); err != nil {
			return err
		}

		if print {
			absPath, _ := filepath.Abs(filename)
			log.Println(absPath)
		}
	}

	return nil
}

func helpmsg() {
	fmt.Println("Usage: metagen [options...]")
	fmt.Println("build :: Build dependencies, generate code, then build final executables.")
	fmt.Println("migrate [up, down, goto {V}, create {migration name}] :: Deploy and create SQL migrations.")
	os.Exit(1)
}

func preBuild() {
	if envtype == ENVIRONMENT_DEV {
		fmt.Println("[DEBUG ENVIRONMENT]")
	} else if envtype == ENVIRONMENT_STAGING || envtype == ENVIRONMENT_PRODUCTION {
		fmt.Println("[RELEASE ENVIRONMENT]")
	}

	// db creation
	maybeCreateSqliteDb()

	// codegen
	generateDebugConfig()
	generatePageData()
	generateJetModels()
	generateTailwindCSS()
}

func build() {
	compileServer()
}

func generateTailwindCSS() {
	tailwindcmd := ""

	fmt.Printf("Generating TailwindCSS stylesheet(s)")

	if runtime.GOOS == "windows" && runtime.GOARCH == "amd64" {
		tailwindcmd = "tailwindcss-windows-x64.exe"
	} else if runtime.GOOS == "darwin" && runtime.GOARCH == "arm64" {
		tailwindcmd = "tailwindcss-macos-arm64"
	} else {
		printStatus(false)
		fmt.Println("OS or ARCH not supported.")
		os.Exit(1)
	}

	// if not found, try to install it
	if _, err := os.Stat(tailwindcmd); err != nil {
		if runtime.GOOS == "windows" && runtime.GOARCH == "amd64" {
			handleCmdOutput(exec.Command(
				"curl.exe", "-LJO", "--output", tailwindcmd,
				"https://github.com/tailwindlabs/tailwindcss/releases/download/v4.0.1/tailwindcss-windows-x64.exe",
			).CombinedOutput())
		} else if runtime.GOOS == "darwin" && runtime.GOARCH == "arm64" {
			handleCmdOutput(exec.Command(
				"curl", "-LJO", "--output", tailwindcmd,
				"https://github.com/tailwindlabs/tailwindcss/releases/download/v4.0.1/tailwindcss-macos-arm64",
			).CombinedOutput())
			handleCmdOutput(exec.Command("chmod", "+x", tailwindcmd).CombinedOutput())
		}
	}

	cmd := exec.Command("./"+tailwindcmd, "-i", "styles/global.css", "-o", "wwwroot/css/tw.min.css", "--minify")
	handleCmdOutput(cmd.CombinedOutput())
	printStatus(true)
}

func compileServer() {
	var out []byte
	var err error

	fmt.Printf("Compiling Server Binary")

	if envtype == ENVIRONMENT_DEV {
		// include extra flags for the GC
		out, err = exec.Command("go", "build", "-gcflags=all=-N -l", "./cmd/server").CombinedOutput()
	} else {
		out, err = exec.Command("go", "build", "./cmd/server").CombinedOutput()
	}

	handleCmdOutput(out, err)
	printStatus(true)
}

// set debug constant inside the "config" package
func generateDebugConfig() {
	fmt.Printf("Generating DEBUG/RELEASE config")

	code := METAGEN_AUTO_COMMENT + "\npackage config\n\nconst (\n"

	if envtype == ENVIRONMENT_DEV {
		code += "	DEBUG = true"
	} else {
		code += "	DEBUG = false"
	}

	code += "\n)\n"

	// open file and write code to it
	in := []byte(code)

	err := os.WriteFile("./config/debug.metagen.go", in, 0644)
	handleErr(err)

	printStatus(true)
}

// Generates routes from files named `*_page.go` found recursively inside the `/src/pages` directory.
// When parsing files, we search for the first function suffixed with `Page`, if one is not found, return an error and fail compilation.
type RouteInfo struct {
	FileDef  string
	URL      string
	PageName string
	Package  string
	Import   string

	Identity      bool `note:"true"`
	Protected     bool `note:"true"`
	CookieSession bool `note:"true"`
	EnableCors    bool `note:"true"`

	// Used to determine if page should be pre-rendered at compile time.
	Static bool `note:"true"`

	// http verbs
	HttpPost   bool `note:"true"`
	HttpGet    bool `note:"true"`
	HttpPut    bool `note:"true"`
	HttpPatch  bool `note:"true"`
	HttpDelete bool `note:"true"`
}

func generatePageData() {
	const root = "pages" // Use the /pages directory for autogenerating routes

	bi, _ := debug.ReadBuildInfo()
	parts := strings.Split(bi.Path, "/")
	module_name := parts[0]

	fmt.Printf("Generating HTTP routes")

	var routeList []RouteInfo

	// Walk the filesystem recursively
	err := filepath.Walk(root, func(pathStr string, info os.FileInfo, err error) error {
		pathStr = filepath.ToSlash(pathStr)

		handleErr(err)

		// Only process .go files
		if strings.HasSuffix(info.Name(), "_page.go") {
			file, err := os.Open(pathStr)
			handleErr(err)

			defer file.Close()

			fs := token.NewFileSet()
			node, err := parser.ParseFile(fs, pathStr, file, parser.ParseComments)
			handleErr(err)

			found := false

			for _, decl := range node.Decls {
				if found {
					break
				}

				// Look for function declarations
				if funcDecl, ok := decl.(*ast.FuncDecl); ok {
					ri := RouteInfo{}

					if funcDecl, ok := decl.(*ast.FuncDecl); ok {
						identifier := funcDecl.Name.Name
						// page functions MUST end with the word "Page" (case sensitive)
						if strings.HasSuffix(identifier, "Page") {
							found = true
						} else {
							continue
						}
					}

					handleErr(parseNotesFromDocComment(decl, file, &ri))

					relativePath := strings.TrimPrefix(pathStr, root)
					relativePath = strings.TrimSuffix(relativePath, "_page.go")

					dirPath := filepath.Dir(relativePath)
					lastDir := filepath.Base(dirPath)

					// Combine last directory and function name
					// Also replace underscore characters "_" with hyphen characters "-"
					ri.URL = strings.ReplaceAll(relativePath, "_", "-")
					ri.Package = lastDir
					ri.PageName = funcDecl.Name.Name

					ri.FileDef = file.Name()

					// strip names from route and use the base package name if file is index
					if strings.HasSuffix(pathStr, "/index_page.go") {
						ri.URL = path.Dir(ri.URL)
					}

					// if the route is in the "root" folder, make sure it imports the correct package.
					ri.Package = filepath.ToSlash(ri.Package)

					if ri.Package == "/" {
						ri.Package = "pages"
						ri.Import = module_name + "/" + ri.Package
						ri.PageName = strings.ReplaceAll(ri.PageName, "/", "pages")
					} else {
						ri.Import = module_name + "/" + root + "/" + removeLastPart(strings.TrimPrefix(relativePath, "/"))
					}

					routeList = append(routeList, ri)
				}
			}

			if !found {
				return fmt.Errorf("\n`%s`: Attempted to generate route, but no function suffixed with `Page` found.", file.Name())
			}
		}

		return nil
	})

	handleErr(err)

	// -- GENERATE ROUTE FILE --
	routeCode := METAGEN_AUTO_COMMENT + "\npackage main\n"

	routeCode += "\nimport (\n\t\"net/http\"\n"

	for _, v := range routeList {
		if v.Identity || v.CookieSession || v.EnableCors {
			routeCode += "	. \"" + module_name + "/middleware\"\n"
			break
		}
	}

	// the go import system is horrible, so the following is a package auto-importer/ de-duplicator for code generation.
	// search through all routes, figure out their package based on the import, and possibly rename it if there already exists an import in
	// the same namespace.

	packageMap := make(map[string][]RouteInfo)
	seenImport := make(map[string]bool)

	// group by package
	for _, route := range routeList {
		// entry de-duplication
		if !seenImport[route.Import] {
			packageMap[route.Package] = append(packageMap[route.Package], route)
		}

		seenImport[route.Import] = true
	}

	// iterate over each sub-group
	for _, routes := range packageMap {
		// don't give the first instance a named import, only subsequent entries
		if len(routes) > 0 {
			routes[0].Import = fmt.Sprintf("\"%s\"", routes[0].Import)
		}

		if len(routes) > 1 {
			// modify the package name in the routeList to include the index of the sublist
			// (this is the whole point -- automatically giving duplicate packages named imports)
			for i := 1; i < len(routes); i += 1 {
				for j, v := range routeList {
					if v.Import == routes[i].Import {
						routeList[j].Package = fmt.Sprintf("%s%d", routes[i].Package, i)
					}
				}

				routes[i].Import = fmt.Sprintf("%s%d \"%s\"", routes[i].Package, i, routes[i].Import)
			}
		}
	}

	var result []RouteInfo
	for _, routes := range packageMap {
		result = append(result, routes...)
	}

	for i := range result {
		routeCode += fmt.Sprintf("\t%s\n", result[i].Import)
	}

	routeCode += ")\n"
	routeCode += "\nfunc mapAutoRoutes(mux *http.ServeMux) {\n"

	for _, routeInfo := range routeList {
		printablePage := routeInfo.Package + "." + routeInfo.PageName

		if routeInfo.CookieSession {
			printablePage = fmt.Sprintf("LoadSessionFromCookie(%s)", printablePage)
		}

		if routeInfo.Identity {
			printablePage = fmt.Sprintf("LoadIdentity(%s, %t)", printablePage, routeInfo.Protected)
		}

		if routeInfo.EnableCors {
			printablePage = fmt.Sprintf("EnableCors(%s)", printablePage)
		}

		httpVerb := ""
		if routeInfo.HttpGet {
			httpVerb = "GET "
		} else if routeInfo.HttpPost {
			httpVerb = "POST "
		} else if routeInfo.HttpPut {
			httpVerb = "PUT "
		} else if routeInfo.HttpPatch {
			httpVerb = "PATCH "
		} else if routeInfo.HttpDelete {
			httpVerb = "DELETE "
		}

		routeCode += fmt.Sprintf("\tmux.HandleFunc(\"%s%s\", %s)\n", httpVerb, routeInfo.URL, printablePage)
	}

	routeCode += "}"

	in := []byte(routeCode)

	fileErr := os.WriteFile("./cmd/server/generated_routes.metagen.go", in, 0644)
	handleErr(fileErr)

	// -- GENERATE PAGEINFO STRUCTS --
	// generate recursive structs representing pages
	// this is used in order to reference a page without needing to actually write out the link as a string literal
	// it also lets you jump to page code whenever that page is referenced in view links or something like that.
	// essentially making dead page links a compile time error if you use this structure.

	newpath := filepath.Join(".", ".metagen/pageinfo")
	dirErr := os.MkdirAll(newpath, os.ModePerm)
	handleErr(dirErr)

	structCode := METAGEN_AUTO_COMMENT
	structCode += "\npackage pageinfo\n\n"

	structCode += "type middleware struct {\n"
	structCode += "\tStatic        bool\n"
	structCode += "\tIdentity      bool\n"
	structCode += "\tProtected     bool\n"
	structCode += "\tCookieSession bool\n"
	structCode += "\tEnableCors    bool\n"
	structCode += "}\n\n"

	structCode += "type PageInfo struct {\n"
	structCode += "\turl            string\n"
	structCode += "\tfileDef        string\n"
	structCode += "\tmiddleware middleware\n"
	structCode += "}\n\n"

	structCode += "func (info PageInfo) Url() string {\n"
	structCode += "\t return info.url\n"
	structCode += "}\n\n"

	structCode += "func (info PageInfo) FileDef() string {\n"
	structCode += "\t return info.fileDef\n"
	structCode += "}\n\n"

	structCode += "func (info PageInfo) Middleware() middleware {\n"
	structCode += "\t return info.middleware\n"
	structCode += "}\n\n"

	structCode += "var (\n"
	structCode += "\tPageInfoList []PageInfo\n"
	structCode += "\tPageInfoMap map[string]PageInfo //maps URLs to PageInfo\n"
	structCode += ")\n\n"

	var pageTree Tree

	pageTree.Name = "Root"

	for _, route := range routeList {
		if route.PageName == "IndexPage" && route.Import != module_name + "/pages" {
			parts := GetPathParts(route.URL)
			parts = append(parts, "index")

			AddStringPartsToTree(&pageTree, parts)
		} else {
			AddStringPartsToTree(&pageTree, GetPathParts(route.URL))
		}
	}

	generateRecursivePageInfoStructs(&structCode, &pageTree, 0)

	structCode += "\n\n"
	structCode += "func init() {\n"
	structCode += "\tPageInfoMap = make(map[string]PageInfo)\n\n"

	for _, v := range routeList {
		structExpansion := strings.ReplaceAll(strings.ReplaceAll(strings.TrimPrefix(v.URL, "/"), "/", "."), "-", "_")
		parts := strings.Split(structExpansion, ".")

		for i, _ := range parts {
			parts[i] = CapitalizeFirstLetter(parts[i])
		}

		structExpansion = strings.Join(parts, ".")

		if structExpansion == "" {
			structExpansion = "Index"
		} else if v.PageName == "IndexPage" {
			structExpansion += ".Index"
		}

		// initialize each pageinfo struct
		structCode += fmt.Sprintf("\tRoot.%s.url = \"%s\"\n", structExpansion, v.URL)
		structCode += fmt.Sprintf("\tRoot.%s.fileDef = \"/%s\"\n", structExpansion, v.FileDef)
		structCode += fmt.Sprintf(
			"\tRoot.%s.middleware = middleware{\n\t\tStatic: %t,\n\t\tIdentity: %t,\n\t\tProtected: %t,\n\t\tCookieSession: %t,\n\t\tEnableCors: %t,\n\t}\n",
			structExpansion,
			v.Static,
			v.Identity,
			v.Protected,
			v.CookieSession,
			v.EnableCors,
		)

		// add to pageinfomap *after* providing the value (duh)
		structCode += fmt.Sprintf("\tPageInfoMap[\"%s\"] = Root.%s\n\n", v.URL, structExpansion)
	}

	structCode += "}\n"

	structCode_b := []byte(structCode)

	structFileErr := os.WriteFile("./.metagen/pageinfo/pageinfo.metagen.go", structCode_b, 0644)
	handleErr(structFileErr)

	printStatus(true)
}

func generateRecursivePageInfoStructs(code *string, tree *Tree, level int) {
	if code == nil {
		return
	}

	if tree == nil {
		return
	}

	// Print the current node with indentation.
	sanitizedName := strings.ReplaceAll(CapitalizeFirstLetter(tree.Name), "-", "_")

	if tree.Children != nil {
		printVar := ""
		if level == 0 {
			printVar = "var "
		}

		*code += fmt.Sprintf("%s%s%s struct {\n", strings.Repeat("\t", level), printVar, sanitizedName)
	} else {
		*code += fmt.Sprintf("%s%s PageInfo\n", strings.Repeat("\t", level), sanitizedName)
	}

	// Recursively print each child.
	if tree.Children != nil {
		for _, child := range *tree.Children {
			generateRecursivePageInfoStructs(code, &child, level+1)
		}
		*code += strings.Repeat("\t", level) + "}\n"
	}

}

func compileJet() {
	fmt.Printf("Compiling Jet generator")

	os.Setenv("CGO_ENABLED", "1")

	cmd := exec.Command("go", "build", "./cmd/jet")
	cmd.Dir = "./tools/jet-2.12.0"
	handleCmdOutput(cmd.CombinedOutput())

}

func generateJetModels() {
	bin := ""
	jetdir := ".jet"

	if runtime.GOOS == "windows" {
		bin = "./tools/jet-2.12.0/jet.exe"
	} else {
		bin = "./tools/jet-2.12.0/jet"
	}

	os.RemoveAll(jetdir)

	// compile bin if not exists
	if _, err := os.Stat(bin); err != nil {
		compileJet()
	}

	fmt.Printf("Generating SQL models (jet)")

	filename, _ := parseSQLiteFilename(config.DbConnectionString)

	if _, err := os.Stat(filename); err != nil {
		printStatus(false)
		fmt.Println("\n" + err.Error())
		os.Exit(1)
	}

	databaseType := "sqlite"

	cmd := exec.Command(bin, "-source="+databaseType, "-dsn="+config.DbConnectionString, "-schema="+config.DbSchema, "-path="+jetdir)

	handleCmdOutput(cmd.CombinedOutput())
	printStatus(true)
}

func parseSQLiteFilename(dsn string) (string, error) {
	u, err := url.Parse(dsn)
	if err != nil {
		return "", err
	}

	// For simple file paths
	if u.Scheme == "" {
		return u.Path, nil
	}

	// For more complex DSNs
	if u.Scheme == "file" {
		return u.Opaque, nil
	}

	return "", fmt.Errorf("invalid DSN format: %s", dsn)
}

// given an ast.Decl, and destination struct, look at the struct for any
// boolean fields with the struct tag `Note`. If valid notes are found in the given Decl doc string
// set the tagged booleans to true on the input struct.
func parseNotesFromDocComment(decl ast.Decl, file *os.File, dest any) error {
	re := regexp.MustCompile(`@(\w+)`)

	var identifier string
	var docstring string

	var docNotes []string
	var validNotes []string

	// check if decl is a function
	if funcDecl, ok := decl.(*ast.FuncDecl); ok {
		identifier = funcDecl.Name.Name
		docstring = funcDecl.Doc.Text()
	}

	matches := re.FindAllStringSubmatch(docstring, -1)

	for _, match := range matches {
		// match[1] contains the first capture group (the word after '@')
		docNotes = append(docNotes, match[1])
	}

	v := reflect.ValueOf(dest).Elem()
	t := v.Type()

	if v.Kind() != reflect.Struct {
		return fmt.Errorf("\ndestination struct must be a pointer to a struct")
	}

	for i := 0; i < v.NumField(); i++ {
		field := t.Field(i)

		// Look for the `Note` tag in the struct field
		if field.Tag == "note:\"true\"" {
			if Contains(docNotes, field.Name) {
				v.Field(i).SetBool(true)
			}

			validNotes = append(validNotes, field.Name)
		}
	}

	for _, v := range docNotes {
		if !Contains(validNotes, v) {
			return fmt.Errorf("\n`%s`: Unknown note `@%s`, Identifier: `%s`\n\tValid values are: %v", file.Name(), v, identifier, validNotes)
		}
	}

	return nil
}

// helpers

// given /foo/bar/baz -> baz
func removeLastPart(s string) string {
	lastSlashIndex := strings.LastIndex(s, "/")

	if lastSlashIndex == -1 {
		return s
	}

	return s[:lastSlashIndex]
}

func printStatus(b bool) {
	var status string

	if b {
		status = "SUCCESS"
	} else {
		status = "FAILED"
	}

	fmt.Printf("... %s\n", status)
}

func handleCmdOutput(out []byte, err error) {
	if err != nil {
		fmt.Printf("\n%s\n", out)
		fmt.Printf("%s\n", err.Error())
		os.Exit(1)
	}
}

func handleErr(err error) {
	if err != nil {
		printStatus(false)
		fmt.Println(err.Error())
		os.Exit(1)
	}
}
