package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"runtime/debug"
	. "saral/basic"
	"strings"
)

var DEBUG bool
var OS string

const METAGEN_AUTO_COMMENT = "// @Metagen -- THIS FILE WAS AUTOGENERATED BY METAGEN - DO NOT EDIT BY HAND"

// metagen - code generator application
//
// Generates code for other applications, such as the server application
func main() {
	// check operating system before running build command
	OS = runtime.GOOS

	println("Metagen - Code Generator and Build System")

	// handle build arguments
	args := os.Args[1:]

	DEBUG = true
	for _, arg := range args {
		switch arg {
		case "release":
			DEBUG = false
		case "debug":
		default:
		}
	}

	if DEBUG {
		println("[COMPILING IN DEBUG MODE]")
	} else {
		println("[COMPILING IN RELEASE MODE]")
	}

	println("")

	// codegen
	generateDebugConfig()
	generateHTTPRoutes()

	// compilation
	compileTailwindCSS()
	compileServer()
	compileMigrator()
}

func compileTailwindCSS() {
	tailwindcmd := ""

	fmt.Printf("[PREPROCESSOR] Compiling TailwindCSS")

	if OS == "windows" {
		log.Fatal("OS unsupported. Compilation failed.")
	} else if OS == "darwin" {
		tailwindcmd = "tailwindcss-macos-arm64"
	}

	out, err := exec.Command("./"+tailwindcmd, "-i", "styles/global.css", "-o", "wwwroot/css/style.css", "--minify").CombinedOutput()
	if err != nil {
		printStatus(false)
		fmt.Printf("%s", out)
		os.Exit(1)
	} else {
		printStatus(true)
	}

	println("")
}

func compileServer() {
	var out []byte
	var err error

	fmt.Printf("[GO COMPILER] Compiling Server Binary")

	// golang imports are horrible so you need this external tool to fix things (unless you want to waste a ton of time cleaning these up yourself). sad!
	// if you dont have this installed, use this:
	// go install golang.org/x/tools/cmd/goimports@latest
	handleCmdOutput(exec.Command("goimports", "-w", "./cmd/server").CombinedOutput())

	if DEBUG {
		// include extra flags for the GC
		// out, err = exec.Command("go", "build", "-gcflags=all=\"-N -l\"", "./cmd/server").CombinedOutput()
		out, err = exec.Command("go", "build", "./cmd/server").CombinedOutput()
	} else {
		out, err = exec.Command("go", "build", "./cmd/server").CombinedOutput()
	}

	handleCmdOutput(out, err)

	println("")
}

func compileMigrator() {
	fmt.Printf("[GO COMPILER] Compiling SQL Migrator")

	out, err := exec.Command("go", "build", "./cmd/server").CombinedOutput()
	handleCmdOutput(out, err)
	println("")
}

// set debug constant inside the "config" package
func generateDebugConfig() {
	fmt.Printf("[CODE GENERATION] Generating DEBUG Config")

	code := METAGEN_AUTO_COMMENT + `
package config

const (
`

	if DEBUG {
		code += `	DEBUG = true
`
	} else {
		code += `	DEBUG = false
`
	}

	code += `
)
`

	// open file and write code to it
	in := []byte(code)

	err := os.WriteFile("./config/debug.metagen.go", in, 0644)
	handleErr(err)

	printStatus(true)
	println("")
}

// Generates routes from files named `*_controller.go` found recursively inside the `/src/pages` directory.
// When parsing files, we search for the first function suffixed with `Controller`, if one is not found, return an error and fail compilation.
func generateHTTPRoutes() {
	type RouteInfo struct {
		URL        string
		Controller string
		Identity   bool `note`
		Protected  bool `note`
		Session    bool `note`
	}

	const root = "pages" // Use the /pages directory for autogenerating routes

	bi, _ := debug.ReadBuildInfo()
	parts := strings.Split(bi.Path, "/")
	module_name := parts[0]

	fmt.Printf("[CODE GENERATION] Generating HTTP Routes")

	var routeList []RouteInfo
	var importList []string

	// Walk the filesystem recursively
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		handleErr(err)

		// Only process .go files
		if strings.HasSuffix(info.Name(), "_controller.go") {
			// Open the file
			file, err := os.Open(path)
			handleErr(err)

			defer file.Close()

			// Parse the file using the go/parser package
			fs := token.NewFileSet()
			node, err := parser.ParseFile(fs, path, file, parser.ParseComments)
			handleErr(err)

			// Traverse the file and find the first function that ends in "Controller"
			found := false

			for _, decl := range node.Decls {
				if found {
					break
				}

				// Look for function declarations
				if funcDecl, ok := decl.(*ast.FuncDecl); ok {
					ri := RouteInfo{}

					if funcDecl, ok := decl.(*ast.FuncDecl); ok {
						identifier := funcDecl.Name.Name
						// controller functions MUST end with the word "Controller" (case sensitive)
						if strings.HasSuffix(identifier, "Controller") {
							found = true
						} else {
							continue
						}
					}

					handleErr(parseNotesFromDocComment(decl, file, &ri))

					relativePath := strings.TrimPrefix(path, root)
					relativePath = strings.TrimSuffix(relativePath, "_controller.go")

					// Extract the last directory name
					dirPath := filepath.Dir(relativePath)
					lastDir := filepath.Base(dirPath)

					// Combine last directory and function name
					// Also replace underscore characters "_" with hyphen characters "-"
					ri.URL = strings.ReplaceAll(relativePath, "_", "-")
					ri.Controller = fmt.Sprintf("%s.%s", lastDir, funcDecl.Name.Name)

					import_name := module_name + "/" + root + "/" + removeLastPart(strings.TrimPrefix(relativePath, "/"))

					routeList = append(routeList, ri)

					if len(importList) == 0 || !Contains[string](importList, import_name) {
						importList = append(importList, import_name)
					}
				}
			}

			if !found {
				return fmt.Errorf("\nAttempted to generate route, but no `Controller` function defined in: `%s`", file.Name())
			}
		}

		return nil
	})

	handleErr(err)

	// generate code
	code := METAGEN_AUTO_COMMENT + `
package main
`

	code += `
import (
	"net/http"
`

	insertMiddlewareImport := false
	for _, v := range routeList {
		if v.Identity || v.Session {
			insertMiddlewareImport = true
		}
	}

	if insertMiddlewareImport {
		code += "	\"saral/middleware\"\n"
	}

	for _, v := range importList {
		code += fmt.Sprintf("	\"%s\"\n", v)
	}

	code += `)
`

	code += `
func mapAutoRoutes(mux *http.ServeMux) {
`
	for _, routeInfo := range routeList {

		if routeInfo.Session {
			routeInfo.Controller = fmt.Sprintf("middleware.LoadSessionFromCookie(%s)", routeInfo.Controller)
		}

		if routeInfo.Identity {
			routeInfo.Controller = fmt.Sprintf("middleware.LoadIdentity(%s, %t)", routeInfo.Controller, routeInfo.Protected)
		}

		code += fmt.Sprintf("	mux.HandleFunc(\"%s\", %s)\n", routeInfo.URL, routeInfo.Controller)
	}

	code += `}`

	in := []byte(code)

	fileErr := os.WriteFile("./cmd/server/generated_routes.metagen.go", in, 0644)
	handleErr(fileErr)

	printStatus(true)
	println("")
}
