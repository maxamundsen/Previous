package main

import (
	"log"
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"path/filepath"
	"go/parser"
	"go/token"
	"regexp"
	"reflect"
	"strings"
	"go/ast"
	"runtime/debug"
	. "saral/basic"
)

var DEBUG bool
var OS string

const METAGEN_AUTO_COMMENT = "// @Metagen -- THIS FILE WAS AUTOGENERATED BY METAGEN - DO NOT EDIT BY HAND"
// metagen - code generator application
//
// Generates code for other applications, such as the server application
func main() {
	// check operating system before running build command
	OS = runtime.GOOS

	println("Metagen - Code Generator and Build System")

	// handle build arguments
	args := os.Args[1:]

	DEBUG = true
	for _, arg := range args {
		switch arg {
		case "release":
			DEBUG = false
		case "debug":
		default:
		}
	}

	if DEBUG {
		println("[COMPILING IN DEBUG MODE]")
	} else {
		println("[COMPILING IN RELEASE MODE]")
	}

	println("")

	compileTailwindCSS()

	// codegen
	setDebugConstant()
	generateHTTPRoutes()

	// actual compilation
	compileServer()
	compileMigrator()
}

func compileTailwindCSS() {
	tailwindcmd := ""

	fmt.Printf("Compiling TailwindCSS")

	if OS == "windows" {
		log.Fatal("OS unsupported. Compilation failed.")
	} else if OS == "darwin" {
		tailwindcmd = "tailwindcss-macos-arm64"
	}

	out, err := exec.Command("./" + tailwindcmd, "-i", "styles/global.css", "-o", "wwwroot/css/style.css", "--minify").CombinedOutput()
	if err != nil {
		printStatus(false)
		fmt.Printf("%s", out)
		os.Exit(1)
	} else {
		printStatus(true)
	}

	println("")
}

func compileServer() {
	var out []byte
	var err error

	fmt.Printf("Compiling Server Binary")

	if DEBUG {
		// include extra flags for the GC
		// out, err = exec.Command("go", "build", "-gcflags=all=\"-N -l\"", "./cmd/server").CombinedOutput()
		out, err = exec.Command("go", "build", "./cmd/server").CombinedOutput()
	} else {
		out, err = exec.Command("go", "build", "./cmd/server").CombinedOutput()
	}

	handleCmdOutput(out, err)

	println("")
}

func compileMigrator() {
	fmt.Printf("Compiling SQL Migrator")

	out, err := exec.Command("go", "build", "./cmd/server").CombinedOutput()
	handleCmdOutput(out, err)
	println("")
}

// set debug constant inside the "config" package
func setDebugConstant() {
	fmt.Printf("[Codegen] Generating DEBUG Config")

	code := METAGEN_AUTO_COMMENT + `
package config

const (
`

	if DEBUG {
		code += `	DEBUG = true
`
	} else {
		code += `	DEBUG = false
`
	}

	code += `
)
`

	// open file and write code to it
	in := []byte(code)

	err := os.WriteFile("./config/debug.go", in, 0644)
	handleErr(err)

	printStatus(true)
	println("")
}


// given a doc string and destination struct, look at the struct for any
// boolean fields tagged `Note`. If valid notes are found in the given string
// set the tagged booleans to true on the input struct.
func parseNotesFromDocComment(doc string, dest any) error {
	re := regexp.MustCompile(`@(\w+)`)

	var notes []string

	matches := re.FindAllStringSubmatch(doc, -1)

	for _, match := range matches {
		// match[1] contains the first capture group (the word after '@')
		notes = append(notes, match[1])
	}

	v := reflect.ValueOf(dest).Elem()
	t := v.Type()

	if v.Kind() != reflect.Struct {
		return fmt.Errorf("\ndestination struct must be a pointer to a struct")
	}

	for i := 0; i < v.NumField(); i++ {
		field := t.Field(i)

		// @TODO fix this! - if you give a tag that isn't supported, spit out an error!
		// Look for the `Note` tag in the struct field
		if field.Tag == "note" {
			if Contains[string](notes, field.Name) {
				v.Field(i).SetBool(true)
			}
		}
	}

	return nil
}

func generateHTTPRoutes() {
	type RouteInfo struct {
		URL string
		Controller string
		Identity bool `note`
		Protected bool `note`
		Session bool `note`
	}

	const root = "pages" // Use the /pages directory for autogenerating routes

	bi, _ := debug.ReadBuildInfo()
	parts := strings.Split(bi.Path, "/")
	module_name := parts[0]

	fmt.Printf("[Codegen] Generating HTTP Routes")

	var routeList []RouteInfo
	var importList []string

	// Walk the filesystem recursively
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		handleErr(err)

		// Only process .go files
		if strings.HasSuffix(info.Name(), "_controller.go") {
			// Open the file
			file, err := os.Open(path)
			handleErr(err)

			defer file.Close()

			// Parse the file using the go/parser package
			fs := token.NewFileSet()
			node, err := parser.ParseFile(fs, path, file, parser.ParseComments)
			handleErr(err)

			// Traverse the file and find the first function
			for _, decl := range node.Decls {
				// Look for function declarations
				if funcDecl, ok := decl.(*ast.FuncDecl); ok {
					ri := RouteInfo{}

					// parse doc string
					docString := strings.TrimSpace(funcDecl.Doc.Text())

					handleErr(parseNotesFromDocComment(docString, &ri))

					relativePath := strings.TrimPrefix(path, root)
					relativePath = strings.TrimSuffix(relativePath, "_controller.go")

					// Extract the last directory name
					dirPath := filepath.Dir(relativePath)
					lastDir := filepath.Base(dirPath)

					// Combine last directory and function name
					// Also replace underscore characters "_" with hyphen characters "-"
					ri.URL = strings.ReplaceAll(relativePath, "_", "-")
					ri.Controller = fmt.Sprintf("%s.%s", lastDir, funcDecl.Name.Name)

					import_name := module_name + "/" + root + "/" + removeLastPart(strings.TrimPrefix(relativePath, "/"))

					routeList = append(routeList, ri)

					if len(importList) == 0  || !Contains[string](importList, import_name) {
						importList = append(importList, import_name)
					}

					break // We only need the first function
				}
			}
		}

		return nil
	})

	handleErr(err)

	// generate code
	code := METAGEN_AUTO_COMMENT + `
package main
`

	code += `
import (
	"net/http"
`

	insertMiddlewareImport := false
	for _, v := range routeList {
		if v.Identity || v.Session {
			insertMiddlewareImport = true
		}
	}

	if insertMiddlewareImport {
		code += "	\"saral/middleware\"\n"
	}

	for _, v := range importList {
		code += fmt.Sprintf("	\"%s\"\n", v)
	}

	code += `)
`


	code += `
func mapAutoRoutes(mux *http.ServeMux) {
`
	for _, routeInfo := range routeList {

		if routeInfo.Session {
			routeInfo.Controller = fmt.Sprintf("middleware.LoadSessionFromCookie(%s)", routeInfo.Controller)
		}

		if routeInfo.Identity {
			routeInfo.Controller = fmt.Sprintf("middleware.LoadIdentity(%s, %t)", routeInfo.Controller, routeInfo.Protected)
		}

		code += fmt.Sprintf("	mux.HandleFunc(\"%s\", %s)\n", routeInfo.URL, routeInfo.Controller)
	}

	code += `}`

	in := []byte(code)

	fileErr := os.WriteFile("./cmd/server/generated_routes.go", in, 0644)
	handleErr(fileErr)

	printStatus(true)
	println("")
}

// helpers
func removeLastPart(s string) string {
	// Find the last occurrence of "/"
	lastSlashIndex := strings.LastIndex(s, "/")

	// If there is no "/" in the string, return the string itself
	if lastSlashIndex == -1 {
		return s
	}

	// Return everything before the last "/"
	return s[:lastSlashIndex]
}

var reset = "\033[0m"
var red = "\033[31m"
var green = "\033[32m"
var yellow = "\033[33m"
var blue = "\033[34m"
var magenta = "\033[35m"
var cyan = "\033[36m"
var gray = "\033[37m"
var white = "\033[97m"

func printStatus(b bool) {
	var status string

	if b {
		status = green + "SUCCESS" + reset
	} else {
		status = red + "FAILED" + reset
	}

	fmt.Printf("... %s", status)
}

func handleCmdOutput(out []byte, err error) {
	if err != nil {
		printStatus(false)
		println("")
		fmt.Printf("%s", out)
		os.Exit(1)
	} else {
		printStatus(true)
	}
}

func handleErr(err error) {
	if err != nil {
		printStatus(false)
		println(err.Error())
		os.Exit(1)
	}
}
