package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"runtime"
	"runtime/debug"
	"strings"
	"regexp"
	"reflect"
	. "previous/basic"
)

var DEBUG bool
var OS string

const METAGEN_AUTO_COMMENT = "// @Metagen -- THIS FILE WAS AUTOGENERATED BY METAGEN - DO NOT EDIT BY HAND"

// metagen - code generator application
//
// Generates code for other applications, such as the server application
func main() {
	// check operating system before running build command
	OS = runtime.GOOS

	println("Metagen - Code Generator and Build System")

	// handle build arguments
	args := os.Args[1:]

	DEBUG = true
	for _, arg := range args {
		switch arg {
		case "release":
			DEBUG = false
		case "debug":
		default:
		}
	}

	if DEBUG {
		println("[COMPILING IN DEBUG MODE]")
	} else {
		println("[COMPILING IN RELEASE MODE]")
	}

	println("")

	// codegen
	generateDebugConfig()
	generateHTTPRoutes()

	// compilation
	compileTailwindCSS()
	compileServer()
	compileMigrator()
}

func compileTailwindCSS() {
	tailwindcmd := ""

	fmt.Printf("[PREPROCESSOR] Generating TailwindCSS stylesheet(s)")

	if OS == "windows" {
		log.Fatal("OS unsupported. Compilation failed.")
	} else if OS == "darwin" {
		tailwindcmd = "tailwindcss-macos-arm64"
	}

	out, err := exec.Command("./"+tailwindcmd, "-i", "styles/global.css", "-o", "wwwroot/css/style.css", "--minify").CombinedOutput()
	if err != nil {
		printStatus(false)
		fmt.Printf("%s", out)
		os.Exit(1)
	} else {
		printStatus(true)
	}

	println("")
}

func compileServer() {
	var out []byte
	var err error

	fmt.Printf("[GO COMPILER] Compiling Server Binary")

	if DEBUG {
		// include extra flags for the GC
		// out, err = exec.Command("go", "build", "-gcflags=all=\"-N -l\"", "./cmd/server").CombinedOutput()
		out, err = exec.Command("go", "build", "./cmd/server").CombinedOutput()
	} else {
		out, err = exec.Command("go", "build", "./cmd/server").CombinedOutput()
	}

	handleCmdOutput(out, err)

	println("")
}

func compileMigrator() {
	fmt.Printf("[GO COMPILER] Compiling SQL Migrator")

	out, err := exec.Command("go", "build", "./cmd/server").CombinedOutput()
	handleCmdOutput(out, err)
	println("")
}

// set debug constant inside the "config" package
func generateDebugConfig() {
	fmt.Printf("[CODE GENERATION] Generating DEBUG/RELEASE config")

	code := METAGEN_AUTO_COMMENT + "\npackage config\n\nconst (\n"

	if DEBUG {
		code += "	DEBUG = true"
	} else {
		code += "	DEBUG = false"
	}

	code += "\n)\n"

	// open file and write code to it
	in := []byte(code)

	err := os.WriteFile("./config/debug.metagen.go", in, 0644)
	handleErr(err)

	printStatus(true)
	println("")
}

// Generates routes from files named `*_controller.go` found recursively inside the `/src/pages` directory.
// When parsing files, we search for the first function suffixed with `Controller`, if one is not found, return an error and fail compilation.
func generateHTTPRoutes() {
	type RouteInfo struct {
		URL        string
		Controller string
		Package    string
		Import     string

		Identity   bool `note`
		Protected  bool `note`
		CookieSession    bool `note`

		// http verbs
		HttpPost bool `note`
		HttpGet bool `note`
		HttpPut bool `note`
		HttpPatch bool `note`
		HttpDelete bool `note`
	}

	const root = "pages" // Use the /pages directory for autogenerating routes

	bi, _ := debug.ReadBuildInfo()
	parts := strings.Split(bi.Path, "/")
	module_name := parts[0]

	fmt.Printf("[CODE GENERATION] Generating HTTP routes")

	var routeList []RouteInfo

	// Walk the filesystem recursively
	err := filepath.Walk(root, func(pathStr string, info os.FileInfo, err error) error {
		handleErr(err)

		// Only process .go files
		if strings.HasSuffix(info.Name(), "_controller.go") {
			// Open the file
			file, err := os.Open(pathStr)
			handleErr(err)

			defer file.Close()

			// Parse the file using the go/parser package
			fs := token.NewFileSet()
			node, err := parser.ParseFile(fs, pathStr, file, parser.ParseComments)
			handleErr(err)

			// Traverse the file and find the first function that ends in "Controller"
			found := false

			for _, decl := range node.Decls {
				if found {
					break
				}

				// Look for function declarations
				if funcDecl, ok := decl.(*ast.FuncDecl); ok {
					ri := RouteInfo{}

					if funcDecl, ok := decl.(*ast.FuncDecl); ok {
						identifier := funcDecl.Name.Name
						// controller functions MUST end with the word "Controller" (case sensitive)
						if strings.HasSuffix(identifier, "Controller") {
							found = true
						} else {
							continue
						}
					}

					handleErr(parseNotesFromDocComment(decl, file, &ri))

					relativePath := strings.TrimPrefix(pathStr, root)
					relativePath = strings.TrimSuffix(relativePath, "_controller.go")

					// Extract the last directory name
					dirPath := filepath.Dir(relativePath)
					lastDir := filepath.Base(dirPath)

					// Combine last directory and function name
					// Also replace underscore characters "_" with hyphen characters "-"
					ri.URL = strings.ReplaceAll(relativePath, "_", "-")
					ri.Package = lastDir
					ri.Controller = funcDecl.Name.Name

					// strip names from route and use the base package name if file is index
					if strings.HasSuffix(pathStr, "/index_controller.go") {
						ri.URL = path.Dir(ri.URL)
					}

					// if the route is in the "root" folder, make sure it imports the correct package.
					if strings.HasPrefix(ri.Controller, "/.") {
						ri.Controller = strings.ReplaceAll(ri.Controller, "/", "pages")
					}

					ri.Import = module_name + "/" + root + "/" + removeLastPart(strings.TrimPrefix(relativePath, "/"))

					routeList = append(routeList, ri)
				}
			}

			if !found {
				return fmt.Errorf("\n`%s`: Attempted to generate route, but no `Controller` found.", file.Name())
			}
		}

		return nil
	})

	handleErr(err)

	// generate code
	code := METAGEN_AUTO_COMMENT + "\npackage main\n"

	code += "\nimport (\n\t\"net/http\"\n"

	for _, v := range routeList {
		if v.Identity || v.CookieSession {
			code += "	\"previous/middleware\"\n"
			break
		}
	}

	// the go import system is horrible, so the following is a package auto-importer/ de-duplicator for code generation.
	// search through all routes, figure out their package based on the import, and possibly rename it if there already exists an import in
	// the same namespace.

	packageMap := make(map[string][]RouteInfo)
	seenImport := make(map[string]bool)

	// group by package
	for _, route := range routeList {
		// entry de-duplication
		if !seenImport[route.Import] {
			packageMap[route.Package] = append(packageMap[route.Package], route)
		}

		seenImport[route.Import] = true
	}

	// iterate over each sub-group
	for _, routes := range packageMap {
		// don't give the first instance a named import, only subsequent entries
		if len(routes) > 0 {
			routes[0].Import = fmt.Sprintf("\"%s\"", routes[0].Import)
		}

		if len(routes) > 1 {
			// modify the package name in the routeList to include the index of the sublist
			// (this is the whole point -- automatically giving duplicate packages named imports)
			for i := 1; i < len(routes); i += 1 {
				for j, v := range routeList {
					if v.Import == routes[i].Import {
						routeList[j].Package = fmt.Sprintf("%s%d", routes[i].Package, i)
					}
				}

				routes[i].Import = fmt.Sprintf("%s%d \"%s\"", routes[i].Package, i, routes[i].Import)
			}
		}
	}

	var result []RouteInfo
	for _, routes := range packageMap {
		result = append(result, routes...)
	}

	for i, _ := range result {
		code += fmt.Sprintf("\t%s\n", result[i].Import)
	}

	code += ")\n"
	code += "\nfunc mapAutoRoutes(mux *http.ServeMux) {\n"

	for _, routeInfo := range routeList {
		printableController := routeInfo.Package + "." + routeInfo.Controller

		if routeInfo.CookieSession {
			printableController = fmt.Sprintf("middleware.LoadSessionFromCookie(%s)", printableController)
		}

		if routeInfo.Identity {
			printableController = fmt.Sprintf("middleware.LoadIdentity(%s, %t)", printableController, routeInfo.Protected)
		}

		httpVerb := ""
		if routeInfo.HttpGet {
			httpVerb = "GET "
		} else if routeInfo.HttpPost {
			httpVerb = "POST "
		} else if routeInfo.HttpPut {
			httpVerb = "PUT "
		} else if routeInfo.HttpPatch {
			httpVerb = "PATCH "
		} else if routeInfo.HttpDelete {
			httpVerb = "DELETE "
		}

		code += fmt.Sprintf("\tmux.HandleFunc(\"%s%s\", %s)\n", httpVerb, routeInfo.URL, printableController)
	}

	code += "}"

	in := []byte(code)

	fileErr := os.WriteFile("./cmd/server/generated_routes.metagen.go", in, 0644)
	handleErr(fileErr)

	printStatus(true)
	println("")
}

// given an ast.Decl, and destination struct, look at the struct for any
// boolean fields with the struct tag `Note`. If valid notes are found in the given Decl doc string
// set the tagged booleans to true on the input struct.
func parseNotesFromDocComment(decl ast.Decl, file *os.File, dest any) error {
	re := regexp.MustCompile(`@(\w+)`)

	var identifier string
	var docstring string

	var docNotes []string
	var validNotes []string

	// check if decl is a function
	if funcDecl, ok := decl.(*ast.FuncDecl); ok {
		identifier = funcDecl.Name.Name
		docstring = funcDecl.Doc.Text()
	}

	matches := re.FindAllStringSubmatch(docstring, -1)

	for _, match := range matches {
		// match[1] contains the first capture group (the word after '@')
		docNotes = append(docNotes, match[1])
	}

	v := reflect.ValueOf(dest).Elem()
	t := v.Type()

	if v.Kind() != reflect.Struct {
		return fmt.Errorf("\ndestination struct must be a pointer to a struct")
	}

	for i := 0; i < v.NumField(); i++ {
		field := t.Field(i)

		// Look for the `Note` tag in the struct field
		if field.Tag == "note" {
			if Contains[string](docNotes, field.Name) {
				v.Field(i).SetBool(true)
			}

			validNotes = append(validNotes, field.Name)
		}
	}

	for _, v := range docNotes {
		if !Contains[string](validNotes, v) {
			return fmt.Errorf("\n`%s`: Unknown note `@%s`, Identifier: `%s`\n\tValid values are: %v", file.Name(), v, identifier, validNotes)
		}
	}

	return nil
}

// helpers

//given /foo/bar/baz -> baz
func removeLastPart(s string) string {
	lastSlashIndex := strings.LastIndex(s, "/")

	if lastSlashIndex == -1 {
		return s
	}

	return s[:lastSlashIndex]
}

var reset = "\033[0m"
var red = "\033[31m"
var green = "\033[32m"
var yellow = "\033[33m"
var blue = "\033[34m"
var magenta = "\033[35m"
var cyan = "\033[36m"
var gray = "\033[37m"
var white = "\033[97m"

func printStatus(b bool) {
	var status string

	if b {
		status = green + "SUCCESS" + reset
	} else {
		status = red + "FAILED" + reset
	}

	fmt.Printf("... %s", status)
}

func handleCmdOutput(out []byte, err error) {
	if err != nil {
		printStatus(false)
		println("")
		fmt.Printf("%s", out)
		os.Exit(1)
	} else {
		printStatus(true)
	}
}

func handleErr(err error) {
	if err != nil {
		printStatus(false)
		println(err.Error())
		os.Exit(1)
	}
}